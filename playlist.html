<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playlist Stats - CarnageReport.com</title>
    <link rel="icon" type="image/x-icon" href="H2CRFinal.ico">
    <link href="https://fonts.googleapis.com/css2?family=Overpass:wght@300;400;600;700&family=Orbitron:wght@400;500;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/highway-gothic" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        .playlist-page {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .playlist-header {
            text-align: center;
            margin-bottom: 30px;
        }
        .playlist-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            color: var(--unsc-blue);
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 5px;
        }
        .playlist-date {
            font-family: 'Share Tech Mono', monospace;
            font-size: 1rem;
            color: rgba(168, 212, 255, 0.7);
            margin-bottom: 10px;
        }
        .playlist-summary {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        .summary-stat {
            text-align: center;
            padding: 15px 25px;
            background: rgba(168, 212, 255, 0.05);
            border: 1px solid rgba(168, 212, 255, 0.2);
            border-radius: 8px;
        }
        .summary-stat .value {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: var(--unsc-blue);
        }
        .summary-stat .label {
            font-size: 0.85rem;
            color: rgba(168, 212, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Tab Navigation */
        .playlist-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }
        .playlist-tab-btn {
            background: rgba(168, 212, 255, 0.1);
            border: 1px solid rgba(168, 212, 255, 0.3);
            color: var(--unsc-blue);
            padding: 12px 24px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .playlist-tab-btn:hover {
            background: rgba(168, 212, 255, 0.2);
        }
        .playlist-tab-btn.active {
            background: rgba(168, 212, 255, 0.25);
            border-color: var(--unsc-blue);
        }
        .playlist-tab-content {
            display: none;
        }
        .playlist-tab-content.active {
            display: block;
        }

        /* ==================== BRACKET STYLES ==================== */
        .bracket-container {
            padding: 20px;
            overflow-x: auto;
        }
        .bracket-wrapper {
            display: flex;
            flex-direction: column;
            gap: 40px;
            min-width: 1100px;
        }


        /* Winners and Losers sections */
        .bracket-section {
            display: flex;
            align-items: center;
            gap: 30px;
        }
        .bracket-section-label {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: rgba(168, 212, 255, 0.5);
            letter-spacing: 2px;
        }

        /* Bracket rounds */
        .bracket-rounds {
            display: flex;
            align-items: center;
            gap: 50px;
        }
        .bracket-round {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Series match box */
        .series-match {
            background: rgba(40, 40, 40, 0.9);
            border: 2px solid rgba(168, 212, 255, 0.2);
            min-width: 220px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .series-match:hover {
            background: rgba(60, 60, 60, 0.9);
        }
        .series-match.expanded {
            background: rgba(50, 50, 50, 0.95);
        }
        .series-match.winner-red {
            border: 3px solid #ef4444;
        }
        .series-match.winner-blue {
            border: 3px solid #3b82f6;
        }

        /* Team row in series - Halo themed red/blue */
        .series-team {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-bottom: 1px solid rgba(80, 80, 80, 0.5);
            gap: 10px;
        }
        .series-team:last-child {
            border-bottom: none;
        }
        .series-team.team-red {
            background: rgba(239, 68, 68, 0.2);
        }
        .series-team.team-blue {
            background: rgba(59, 130, 246, 0.2);
        }
        .team-seed {
            font-family: 'Highway Gothic', sans-serif;
            font-size: 0.85rem;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
            width: 20px;
            text-align: center;
        }
        .team-emblem {
            width: 32px;
            height: 32px;
            border: 2px solid white;
        }
        .team-name {
            flex: 1;
            font-family: 'Highway Gothic', sans-serif;
            font-size: 1rem;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }
        .series-score {
            font-family: 'Highway Gothic', sans-serif;
            font-size: 1rem;
            padding: 4px 12px;
            background: rgba(0, 0, 0, 0.4);
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }

        /* Connector lines */
        .bracket-connector {
            display: flex;
            align-items: center;
        }
        .connector-line {
            width: 30px;
            height: 2px;
            background: rgba(168, 212, 255, 0.3);
        }

        /* Vertical connector from losers to winners */
        .losers-to-winners-connector {
            display: flex;
            align-items: flex-start;
            margin-left: 20px;
        }
        .vertical-tick {
            width: 80px;
            height: 2px;
            background: rgba(168, 212, 255, 0.4);
            position: relative;
            transform: rotate(-45deg);
            transform-origin: left center;
        }
        .vertical-tick::after {
            content: '';
            position: absolute;
            right: -8px;
            top: -5px;
            width: 0;
            height: 0;
            border-left: 8px solid rgba(168, 212, 255, 0.4);
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
        }
        .bracket-section.losers-section {
            position: relative;
        }

        /* Games dropdown for series */
        .series-games-dropdown {
            display: none;
            background: rgba(40, 40, 40, 0.95);
            border: 1px solid rgba(168, 212, 255, 0.3);
            border-top: none;
            padding: 10px;
        }
        .series-match.expanded + .series-games-dropdown,
        .series-games-dropdown.show {
            display: block;
        }
        .series-game-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid rgba(168, 212, 255, 0.1);
            gap: 10px;
        }
        .series-game-item:last-child {
            border-bottom: none;
        }
        .series-game-item.red-win {
            border-left: 3px solid #ef4444;
        }
        .series-game-item.blue-win {
            border-left: 3px solid #3b82f6;
        }
        .game-map-type {
            flex: 1;
            font-family: 'Highway Gothic', sans-serif;
            font-size: 0.9rem;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }
        .game-winner-tag {
            font-family: 'Highway Gothic', sans-serif;
            font-size: 0.8rem;
            padding: 3px 10px;
            border-radius: 2px;
        }
        .game-winner-tag.red {
            background: rgba(239, 68, 68, 0.4);
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }
        .game-winner-tag.blue {
            background: rgba(59, 130, 246, 0.4);
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }
        .reset-divider {
            text-align: center;
            padding: 8px;
            font-family: 'Highway Gothic', sans-serif;
            font-size: 0.85rem;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
            border-top: 1px dashed rgba(255, 255, 255, 0.3);
            border-bottom: 1px dashed rgba(255, 255, 255, 0.3);
            margin: 5px 0;
        }

        /* Stats Table */
        .stats-table-container {
            overflow-x: auto;
        }
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }
        .stats-table th {
            background: linear-gradient(180deg, rgba(168, 212, 255, 0.15) 0%, rgba(168, 212, 255, 0.05) 100%);
            color: var(--unsc-blue);
            font-family: 'Orbitron', sans-serif;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 15px 12px;
            text-align: left;
            border-bottom: 2px solid rgba(168, 212, 255, 0.3);
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }
        .stats-table th:hover {
            background: linear-gradient(180deg, rgba(168, 212, 255, 0.25) 0%, rgba(168, 212, 255, 0.1) 100%);
        }
        .stats-table th.sorted-asc::after {
            content: ' ▲';
            font-size: 0.7em;
        }
        .stats-table th.sorted-desc::after {
            content: ' ▼';
            font-size: 0.7em;
        }
        .stats-table td {
            padding: 12px;
            border-bottom: 1px solid rgba(168, 212, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
        }
        .stats-table tr:hover td {
            background: rgba(168, 212, 255, 0.08);
        }
        .stats-table .player-cell {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .stats-table .player-emblem,
        .scoreboard-table .player-emblem {
            width: 32px;
            height: 32px;
            border: 2px solid white;
        }
        .stats-table .player-name {
            color: var(--unsc-blue);
            font-weight: 600;
            cursor: pointer;
        }
        .stats-table .player-name:hover {
            text-decoration: underline;
        }
        .positive { color: #4ade80; }
        .negative { color: #f87171; }
        .neutral { color: #fbbf24; }

        /* Game details content */
        .game-details-header {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .map-image-container {
            position: relative;
            width: 200px;
            height: 120px;
            flex-shrink: 0;
        }
        .map-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border: 2px solid rgba(168, 212, 255, 0.3);
        }
        .map-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 10px;
        }
        .map-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: #fff;
        }
        .game-info-panel {
            flex: 1;
        }
        .game-type-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: var(--unsc-blue);
            margin-bottom: 10px;
        }
        .game-meta-info {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            color: rgba(255,255,255,0.7);
            font-size: 0.9rem;
        }
        .game-final-score {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }
        .final-score-team {
            padding: 8px 15px;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
        }
        .final-score-team.team-red {
            background: rgba(239, 68, 68, 0.3);
            border: 1px solid #ef4444;
            color: #ef4444;
        }
        .final-score-team.team-blue {
            background: rgba(59, 130, 246, 0.3);
            border: 1px solid #3b82f6;
            color: #3b82f6;
        }
        .final-score-team.winner {
            font-weight: bold;
        }
        .score-separator {
            color: rgba(255,255,255,0.5);
        }

        /* Scoreboard table */
        .scoreboard {
            margin-top: 15px;
        }
        .scoreboard-table {
            width: 100%;
            border-collapse: collapse;
        }
        .scoreboard-table th {
            background: rgba(168, 212, 255, 0.1);
            color: var(--unsc-blue);
            padding: 10px 15px;
            text-align: left;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            text-transform: uppercase;
        }
        .scoreboard-table td {
            padding: 10px 15px;
            border-bottom: 1px solid rgba(168, 212, 255, 0.1);
            color: rgba(255,255,255,0.9);
        }
        .scoreboard-table tr.team-red {
            background: rgba(239, 68, 68, 0.15);
        }
        .scoreboard-table tr.team-blue {
            background: rgba(59, 130, 246, 0.15);
        }
        .scoreboard-table .player-cell {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .scoreboard-table .player-name {
            color: var(--unsc-blue);
            cursor: pointer;
        }
        .scoreboard-table .player-name:hover {
            text-decoration: underline;
        }

        /* Playlist link in game details */
        .playlist-link {
            color: var(--unsc-blue);
            text-decoration: none;
            padding: 4px 10px;
            background: rgba(168, 212, 255, 0.15);
            border-radius: 4px;
            font-size: 0.85rem;
            transition: background 0.2s;
        }
        .playlist-link:hover {
            background: rgba(168, 212, 255, 0.3);
            text-decoration: none;
        }

        /* Games List */
        .games-list-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Bracket info badge in games list */
        .bracket-info-badge {
            background: rgba(255, 255, 255, 0.95);
            color: #1a1a2e;
            padding: 4px 12px;
            border-radius: 4px;
            font-family: 'Highway Gothic', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0 15px;
            white-space: nowrap;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--unsc-blue);
            text-decoration: none;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            margin-bottom: 20px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        .back-link:hover {
            opacity: 1;
        }
        .error-message {
            text-align: center;
            padding: 60px 20px;
            color: #f87171;
            font-family: 'Orbitron', sans-serif;
        }
        .error-message h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
        }
        .loading {
            text-align: center;
            padding: 60px 20px;
            color: var(--unsc-blue);
            font-family: 'Orbitron', sans-serif;
        }
    </style>
</head>
<body>
    <div class="container">
        <header id="mainHeader">
            <div class="header-icons">
                <a href="https://discord.gg/carnagereport" target="_blank" rel="noopener noreferrer" class="header-icon" title="Join Discord">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 127.14 96.36" fill="currentColor">
                        <path d="M107.7,8.07A105.15,105.15,0,0,0,81.47,0a72.06,72.06,0,0,0-3.36,6.83A97.68,97.68,0,0,0,49,6.83,72.37,72.37,0,0,0,45.64,0,105.89,105.89,0,0,0,19.39,8.09C2.79,32.65-1.71,56.6.54,80.21h0A105.73,105.73,0,0,0,32.71,96.36,77.7,77.7,0,0,0,39.6,85.25a68.42,68.42,0,0,1-10.85-5.18c.91-.66,1.8-1.34,2.66-2a75.57,75.57,0,0,0,64.32,0c.87.71,1.76,1.39,2.66,2a68.68,68.68,0,0,1-10.87,5.19,77,77,0,0,0,6.89,11.1A105.25,105.25,0,0,0,126.6,80.22h0C129.24,52.84,122.09,29.11,107.7,8.07ZM42.45,65.69C36.18,65.69,31,60,31,53s5-12.74,11.43-12.74S54,46,53.89,53,48.84,65.69,42.45,65.69Zm42.24,0C78.41,65.69,73.25,60,73.25,53s5-12.74,11.44-12.74S96.23,46,96.12,53,91.08,65.69,84.69,65.69Z"/>
                    </svg>
                </a>
            </div>
            <a href="/">
                <img src="HaloCarnageReport Logo.png" alt="Carnage Report Logo" class="logo" style="cursor: pointer;">
            </a>
        </header>

        <div class="playlist-page">
            <a href="/" class="back-link">&larr; Back to Main</a>

            <div id="loadingArea" class="loading">
                [ LOADING PLAYLIST STATS ]
            </div>

            <div id="errorArea" class="error-message" style="display: none;">
                <h2>Playlist Not Found</h2>
                <p id="errorText">The requested playlist could not be found.</p>
            </div>

            <div id="contentArea" style="display: none;">
                <div class="playlist-header">
                    <h1 class="playlist-title" id="playlistName"></h1>
                    <div class="playlist-date" id="playlistDate"></div>
                </div>

                <div class="playlist-summary" id="playlistSummary"></div>

                <div class="playlist-tabs" id="playlistTabs">
                    <button class="playlist-tab-btn active" data-tab="bracket">Bracket</button>
                    <button class="playlist-tab-btn" data-tab="games">Games List</button>
                    <button class="playlist-tab-btn" data-tab="players">Player Stats</button>
                </div>

                <!-- Bracket Tab -->
                <div id="tab-bracket" class="playlist-tab-content active">
                    <div class="bracket-container" id="bracketContainer">
                        <!-- Bracket will be rendered here -->
                    </div>
                </div>

                <!-- Games List Tab -->
                <div id="tab-games" class="playlist-tab-content">
                    <div class="games-list-container">
                        <div class="game-list" id="playlistGamesList"></div>
                    </div>
                </div>

                <!-- Player Stats Tab -->
                <div id="tab-players" class="playlist-tab-content">
                    <div class="stats-table-container">
                        <table class="stats-table">
                            <thead>
                                <tr id="tableHeader"></tr>
                            </thead>
                            <tbody id="tableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Map images for game cards
        const mapImages = {
            'Ascension': '/assets/maps/ascension.webp',
            'Beaver Creek': '/assets/maps/beavercreek.webp',
            'Burial Mounds': '/assets/maps/burialmounds.webp',
            'Coagulation': '/assets/maps/coagulation.webp',
            'Colossus': '/assets/maps/colossus.webp',
            'Foundation': '/assets/maps/foundation.webp',
            'Headlong': '/assets/maps/headlong.webp',
            'Ivory Tower': '/assets/maps/ivorytower.webp',
            'Lockout': '/assets/maps/lockout.webp',
            'Midship': '/assets/maps/midship.webp',
            'Sanctuary': '/assets/maps/sanctuary.webp',
            'Turf': '/assets/maps/turf.webp',
            'Warlock': '/assets/maps/warlock.webp',
            'Waterworks': '/assets/maps/waterworks.webp',
            'Zanzibar': '/assets/maps/zanzibar.webp',
            'Containment': '/assets/maps/containment.webp',
            'Elongation': '/assets/maps/elongation.webp',
            'Gemini': '/assets/maps/gemini.webp',
            'Relic': '/assets/maps/relic.webp',
            'Terminal': '/assets/maps/terminal.webp',
            'Backwash': '/assets/maps/backwash.webp',
            'Desolation': '/assets/maps/desolation.webp',
            'Tombstone': '/assets/maps/tombstone.webp',
            'District': '/assets/maps/district.webp',
            'Uplift': '/assets/maps/uplift.webp'
        };
        const defaultMapImage = '/assets/maps/default.webp';

        // Get playlist name from URL path
        function getPlaylistName() {
            const path = window.location.pathname;
            let name = path.replace(/^\/playlist\//, '').replace(/^\//, '').replace(/\/$/, '');
            name = decodeURIComponent(name);
            if (!name || name === 'playlist.html') {
                const params = new URLSearchParams(window.location.search);
                name = params.get('name') || params.get('playlist') || '';
            }
            return name;
        }

        // Data storage
        let playersData = [];
        let matchesData = [];
        let teamsData = [];
        let emblemsData = {};
        let mmrData = {};
        let playlistConfig = null;
        let bracketConfig = null;
        let currentSort = { column: 'wins', direction: 'desc' };

        // Player stats columns (no XP)
        const columns = [
            { key: 'player', label: 'Player', sortable: true },
            { key: 'record', label: 'Record', sortable: true, sortKey: 'wins' },
            { key: 'winRate', label: 'Win %', sortable: true },
            { key: 'kills', label: 'Kills', sortable: true },
            { key: 'deaths', label: 'Deaths', sortable: true },
            { key: 'kd', label: 'K/D', sortable: true },
            { key: 'spread', label: '+/-', sortable: true },
            { key: 'assists', label: 'Assists', sortable: true },
            { key: 'headshots', label: 'Headshots', sortable: true }
        ];

        // Tab switching
        document.querySelectorAll('.playlist-tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const tabName = this.dataset.tab;
                document.querySelectorAll('.playlist-tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.playlist-tab-content').forEach(c => c.classList.remove('active'));
                this.classList.add('active');
                document.getElementById(`tab-${tabName}`).classList.add('active');
            });
        });

        // Get team by seed from bracket config
        function getTeamBySeed(seed) {
            if (!bracketConfig || !bracketConfig.teams) return null;
            return bracketConfig.teams.find(t => t.seed === seed);
        }

        // Get captain emblem by captain name
        function getCaptainEmblem(captainName) {
            if (!captainName) return '';
            // Search emblems by discord_name
            for (const [id, data] of Object.entries(emblemsData)) {
                if (data.discord_name && data.discord_name.toLowerCase() === captainName.toLowerCase()) {
                    return data.emblem_url || '';
                }
            }
            // Also check MMR data for discord_id mapping
            for (const [id, data] of Object.entries(mmrData)) {
                if (data.discord_name && data.discord_name.toLowerCase() === captainName.toLowerCase()) {
                    if (emblemsData[id]) {
                        return emblemsData[id].emblem_url || '';
                    }
                }
            }
            return '';
        }

        // Render the bracket
        function renderBracket() {
            const container = document.getElementById('bracketContainer');
            if (!bracketConfig) {
                container.innerHTML = '<div class="loading">No bracket data available</div>';
                return;
            }

            const teams = bracketConfig.teams || [];
            const series = bracketConfig.series || [];
            const rounds = bracketConfig.rounds || {};

            // Build team lookup
            const teamMap = {};
            teams.forEach(t => teamMap[t.seed] = t);

            let html = '<div class="bracket-wrapper">';

            // Winners Bracket
            html += '<div class="bracket-section">';

            // Winners R1
            const winnersR1 = series.filter(s => s.round === 'winners_r1');
            const winnersSemis = series.filter(s => s.round === 'winners_semis');
            const grandFinals = series.filter(s => s.round === 'grand_finals');

            html += '<div class="bracket-rounds">';

            // Round 1 matches
            html += '<div class="bracket-round">';
            winnersR1.forEach(s => {
                html += renderSeriesMatch(s, teamMap);
            });
            html += '</div>';

            // Connector
            html += '<div class="bracket-connector"><div class="connector-line"></div></div>';

            // Semifinals
            html += '<div class="bracket-round">';
            winnersSemis.forEach(s => {
                html += renderSeriesMatch(s, teamMap);
            });
            html += '</div>';

            // Connector
            html += '<div class="bracket-connector"><div class="connector-line"></div></div>';

            // Grand Finals
            html += '<div class="bracket-round">';
            grandFinals.forEach(s => {
                html += renderSeriesMatch(s, teamMap);
            });
            html += '</div>';

            html += '</div>'; // bracket-rounds
            html += '</div>'; // bracket-section

            // Losers Bracket Section
            const losersR1 = series.filter(s => s.round === 'losers_r1');
            const losersR2 = series.filter(s => s.round === 'losers_r2');

            html += '<div class="bracket-section losers-section">';

            // Losers bracket matches
            html += '<div class="bracket-rounds">';

            // Losers R1 matches
            html += '<div class="bracket-round">';
            losersR1.forEach(s => {
                html += renderSeriesMatch(s, teamMap);
            });
            html += '</div>';

            // Connector
            html += '<div class="bracket-connector"><div class="connector-line"></div></div>';

            // Losers R2 matches
            html += '<div class="bracket-round">';
            losersR2.forEach(s => {
                html += renderSeriesMatch(s, teamMap);
            });
            html += '</div>';

            // Diagonal connector from losers to winners
            html += '<div class="losers-to-winners-connector"><div class="vertical-tick"></div></div>';

            html += '</div>'; // bracket-rounds
            html += '</div>'; // bracket-section

            html += '</div>'; // bracket-wrapper

            container.innerHTML = html;

            // Add click handlers for series matches
            container.querySelectorAll('.series-match').forEach(match => {
                match.addEventListener('click', function() {
                    this.classList.toggle('expanded');
                    const dropdown = this.nextElementSibling;
                    if (dropdown && dropdown.classList.contains('series-games-dropdown')) {
                        dropdown.classList.toggle('show');
                    }
                });
            });
        }

        function renderSeriesMatch(series, teamMap) {
            const team1 = teamMap[series.team1_seed] || { name: 'TBD', seed: series.team1_seed };
            const team2 = teamMap[series.team2_seed] || { name: 'TBD', seed: series.team2_seed };

            const team1Emblem = getCaptainEmblem(team1.captain);
            const team2Emblem = getCaptainEmblem(team2.captain);

            const team1Winner = series.winner_seed === series.team1_seed;
            const team2Winner = series.winner_seed === series.team2_seed;

            // Team display names: "Team {Captain}"
            const team1DisplayName = team1.captain ? `Team ${team1.captain}` : team1.name;
            const team2DisplayName = team2.captain ? `Team ${team2.captain}` : team2.name;

            // Determine winner border class
            let winnerBorderClass = '';
            if (team1Winner) winnerBorderClass = 'winner-red';
            else if (team2Winner) winnerBorderClass = 'winner-blue';

            let html = `<div class="series-match ${winnerBorderClass}" data-series-id="${series.id}">`;

            // Team 1 (Red team)
            html += `<div class="series-team team-red">`;
            html += `<span class="team-seed">${team1.seed}</span>`;
            if (team1Emblem) {
                html += `<img src="${team1Emblem}" class="team-emblem" alt="">`;
            }
            html += `<span class="team-name">${team1DisplayName}</span>`;
            html += `<span class="series-score">${series.team1_wins}</span>`;
            html += `</div>`;

            // Team 2 (Blue team)
            html += `<div class="series-team team-blue">`;
            html += `<span class="team-seed">${team2.seed}</span>`;
            if (team2Emblem) {
                html += `<img src="${team2Emblem}" class="team-emblem" alt="">`;
            }
            html += `<span class="team-name">${team2DisplayName}</span>`;
            html += `<span class="series-score">${series.team2_wins}</span>`;
            html += `</div>`;

            html += `</div>`;

            // Games dropdown
            html += `<div class="series-games-dropdown">`;
            html += renderSeriesGames(series, team1, team2);
            html += `</div>`;

            return html;
        }

        function renderSeriesGames(series, team1, team2) {
            // Find games for this series from matchesData
            const roundConfig = bracketConfig.rounds[series.round];
            if (!roundConfig || !roundConfig.games) {
                return '<div style="padding: 10px; color: rgba(255,255,255,0.5);">No game data</div>';
            }

            let html = '';
            const gameNames = roundConfig.games;

            // For grand finals with bracket reset
            if (series.bracket_reset) {
                const midpoint = Math.ceil(gameNames.length / 2);
                const set1Games = gameNames.slice(0, midpoint);
                const set2Games = gameNames.slice(midpoint);

                set1Games.forEach((gameName, idx) => {
                    html += renderGameItem(gameName, idx, series, team1, team2);
                });

                html += '<div class="reset-divider">BRACKET RESET</div>';

                set2Games.forEach((gameName, idx) => {
                    html += renderGameItem(gameName, idx + midpoint, series, team1, team2);
                });
            } else {
                gameNames.forEach((gameName, idx) => {
                    html += renderGameItem(gameName, idx, series, team1, team2);
                });
            }

            return html;
        }

        function renderGameItem(gameName, idx, series, team1, team2) {
            // Try to find the matching game in matchesData
            const matchingGame = findMatchingGame(gameName, series);

            let winnerColor = '';
            let winnerTag = '';

            if (matchingGame) {
                winnerColor = matchingGame.winner === 'Red' ? 'red-win' : 'blue-win';
                winnerTag = matchingGame.winner === 'Red'
                    ? `<span class="game-winner-tag red">RED</span>`
                    : `<span class="game-winner-tag blue">BLUE</span>`;
            }

            return `
                <div class="series-game-item ${winnerColor}">
                    <span class="game-map-type">${gameName}</span>
                    ${winnerTag}
                </div>
            `;
        }

        function findMatchingGame(gameName, series) {
            // Parse game name like "WARLOCK CTF" -> map: Warlock, type includes CTF
            const parts = gameName.split(' ');
            if (parts.length < 2) return null;

            const mapPart = parts[0].toLowerCase();
            const typePart = parts.slice(1).join(' ').toLowerCase();

            // Map name conversions
            const mapNameMap = {
                'sanc': 'sanctuary',
                'beaver': 'beaver creek',
                'lock': 'lockout'
            };

            const searchMap = mapNameMap[mapPart] || mapPart;

            for (const match of matchesData) {
                const matchMap = (match.map || '').toLowerCase();
                const matchType = (match.gametype || '').toLowerCase();

                if (matchMap.includes(searchMap) || searchMap.includes(matchMap.split(' ')[0])) {
                    // Check gametype
                    if (typePart.includes('ctf') && (matchType.includes('flag') || matchType.includes('ctf'))) return match;
                    if (typePart.includes('ts') && matchType.includes('slayer')) return match;
                    if (typePart.includes('slayer') && matchType.includes('slayer')) return match;
                    if (typePart.includes('ball') && (matchType.includes('ball') || matchType.includes('oddball'))) return match;
                    if (typePart.includes('bomb') && (matchType.includes('bomb') || matchType.includes('assault'))) return match;
                    if (typePart.includes('koth') && (matchType.includes('king') || matchType.includes('hill'))) return match;
                }
            }
            return null;
        }

        // Player stats functions
        function renderHeader() {
            const headerRow = document.getElementById('tableHeader');
            headerRow.innerHTML = columns.map(col => {
                const sortClass = currentSort.column === col.key ?
                    (currentSort.direction === 'asc' ? 'sorted-asc' : 'sorted-desc') : '';
                return `<th class="${sortClass}" onclick="sortBy('${col.key}')">${col.label}</th>`;
            }).join('');
        }

        function sortBy(column) {
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'desc';
            }
            renderPlayersTable();
        }

        function getSortValue(player, column) {
            switch (column) {
                case 'player': return player.discord_name.toLowerCase();
                case 'record':
                case 'wins': return player.wins || 0;
                case 'winRate': return player.wins / Math.max(1, player.wins + player.losses);
                case 'kills': return player.kills || 0;
                case 'deaths': return player.deaths || 0;
                case 'kd': return player.kills / Math.max(1, player.deaths);
                case 'spread': return (player.kills || 0) - (player.deaths || 0);
                case 'assists': return player.assists || 0;
                case 'headshots': return player.headshots || 0;
                default: return 0;
            }
        }

        function renderPlayersTable() {
            renderHeader();

            const sorted = [...playersData].sort((a, b) => {
                const aVal = getSortValue(a, currentSort.column);
                const bVal = getSortValue(b, currentSort.column);
                // desc = highest first, asc = lowest first
                if (typeof aVal === 'string') {
                    const cmp = aVal.localeCompare(bVal);
                    return currentSort.direction === 'desc' ? -cmp : cmp;
                }
                return currentSort.direction === 'desc' ? (bVal - aVal) : (aVal - bVal);
            });

            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = sorted.map(player => {
                const emblem = getPlayerEmblem(player.discord_name);
                const kd = (player.kills / Math.max(1, player.deaths)).toFixed(2);
                const winRate = ((player.wins / Math.max(1, player.wins + player.losses)) * 100).toFixed(1);
                const kdClass = kd >= 1.2 ? 'positive' : kd < 0.8 ? 'negative' : 'neutral';
                const spread = (player.kills || 0) - (player.deaths || 0);
                const spreadClass = spread > 0 ? 'positive' : spread < 0 ? 'negative' : 'neutral';
                const spreadDisplay = spread > 0 ? `+${spread}` : spread;

                return `
                    <tr>
                        <td>
                            <div class="player-cell">
                                ${emblem ? `<img src="${emblem}" class="player-emblem" alt="">` : ''}
                                <span class="player-name" onclick="goToPlayer('${player.discord_name}')">${player.discord_name}</span>
                            </div>
                        </td>
                        <td>${player.wins}-${player.losses}</td>
                        <td>${winRate}%</td>
                        <td>${player.kills || 0}</td>
                        <td>${player.deaths || 0}</td>
                        <td class="${kdClass}">${kd}</td>
                        <td class="${spreadClass}">${spreadDisplay}</td>
                        <td>${player.assists || 0}</td>
                        <td>${player.headshots || 0}</td>
                    </tr>
                `;
            }).join('');
        }

        function getPlayerEmblem(playerName) {
            for (const [id, data] of Object.entries(emblemsData)) {
                if (data.discord_name && data.discord_name.toLowerCase() === playerName.toLowerCase()) {
                    return data.emblem_url || '';
                }
            }
            for (const [id, data] of Object.entries(mmrData)) {
                if (data.discord_name && data.discord_name.toLowerCase() === playerName.toLowerCase()) {
                    if (emblemsData[id]) {
                        return emblemsData[id].emblem_url || '';
                    }
                }
            }
            return '';
        }

        function renderSummary() {
            const totalGames = matchesData.length;
            const totalKills = playersData.reduce((sum, p) => sum + (p.kills || 0), 0);

            const summary = document.getElementById('playlistSummary');

            if (bracketConfig && bracketConfig.teams) {
                summary.innerHTML = `
                    <div class="summary-stat">
                        <div class="value">${bracketConfig.teams.length}</div>
                        <div class="label">Teams</div>
                    </div>
                    <div class="summary-stat">
                        <div class="value">${playersData.length}</div>
                        <div class="label">Players</div>
                    </div>
                    <div class="summary-stat">
                        <div class="value">${totalGames}</div>
                        <div class="label">Games Played</div>
                    </div>
                    <div class="summary-stat">
                        <div class="value">${totalKills.toLocaleString()}</div>
                        <div class="label">Total Kills</div>
                    </div>
                `;
            } else {
                summary.innerHTML = `
                    <div class="summary-stat">
                        <div class="value">${playersData.length}</div>
                        <div class="label">Players</div>
                    </div>
                    <div class="summary-stat">
                        <div class="value">${totalGames}</div>
                        <div class="label">Games Played</div>
                    </div>
                    <div class="summary-stat">
                        <div class="value">${totalKills.toLocaleString()}</div>
                        <div class="label">Total Kills</div>
                    </div>
                `;
            }
        }

        // Bracket game mapping - maps games to their series/round info
        let bracketGameMapping = {};

        function buildBracketGameMapping() {
            bracketGameMapping = {};
            if (!bracketConfig || !bracketConfig.series || !bracketConfig.rounds) return;

            // Sort matches chronologically (oldest first) to process in order
            const sortedMatches = [...matchesData].sort((a, b) => {
                const dateA = new Date(a.timestamp || 0);
                const dateB = new Date(b.timestamp || 0);
                return dateA - dateB;
            });

            // Create a unique ID for each match based on timestamp
            const usedMatches = new Set();

            // Process series in order (they should be in chronological order)
            for (const series of bracketConfig.series) {
                const roundConfig = bracketConfig.rounds[series.round];
                if (!roundConfig || !roundConfig.games) continue;

                const roundLabel = roundConfig.label || series.round;
                const expectedGames = roundConfig.games;
                const totalGamesInSeries = series.team1_wins + series.team2_wins;

                let gamesFound = 0;
                let expectedIdx = 0;

                for (let matchIdx = 0; matchIdx < sortedMatches.length && gamesFound < totalGamesInSeries; matchIdx++) {
                    const match = sortedMatches[matchIdx];
                    const matchKey = match.timestamp || matchIdx;

                    // Skip if already assigned
                    if (usedMatches.has(matchKey)) continue;

                    // Check if this match matches the next expected game in the series
                    while (expectedIdx < expectedGames.length) {
                        if (matchGameToExpected(match, expectedGames[expectedIdx])) {
                            bracketGameMapping[matchKey] = {
                                round: roundLabel,
                                gameNumber: gamesFound + 1
                            };
                            usedMatches.add(matchKey);
                            gamesFound++;
                            expectedIdx++;
                            break;
                        }
                        expectedIdx++;
                    }
                }
            }
        }

        function matchGameToExpected(match, expectedGameName) {
            const parts = expectedGameName.split(' ');
            if (parts.length < 2) return false;

            const mapPart = parts[0].toLowerCase();
            const typePart = parts.slice(1).join(' ').toLowerCase();

            const mapNameMap = {
                'sanc': 'sanctuary',
                'beaver': 'beaver creek',
                'lock': 'lockout'
            };

            const searchMap = mapNameMap[mapPart] || mapPart;
            const matchMap = (match.map || '').toLowerCase();
            const matchType = (match.gametype || '').toLowerCase();

            if (!(matchMap.includes(searchMap) || searchMap.includes(matchMap.split(' ')[0]))) {
                return false;
            }

            // Check gametype
            if (typePart.includes('ctf') && (matchType.includes('flag') || matchType.includes('ctf'))) return true;
            if (typePart.includes('ts') && matchType.includes('slayer')) return true;
            if (typePart.includes('slayer') && matchType.includes('slayer')) return true;
            if (typePart.includes('ball') && (matchType.includes('ball') || matchType.includes('oddball'))) return true;
            if (typePart.includes('bomb') && (matchType.includes('bomb') || matchType.includes('assault'))) return true;
            if (typePart.includes('koth') && (matchType.includes('king') || matchType.includes('hill'))) return true;

            return false;
        }

        function getBracketInfoForMatch(match) {
            const matchKey = match.timestamp || '';
            return bracketGameMapping[matchKey] || null;
        }

        // Games list functions
        function formatDuration(duration) {
            if (!duration) return '0:00';
            return duration;
        }

        function formatDateTime(startTime) {
            if (!startTime) return '';
            try {
                const date = new Date(startTime);
                if (isNaN(date.getTime())) return startTime;
                return date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });
            } catch (e) {
                return startTime;
            }
        }

        function getBaseGametype(variantName, playlist = '') {
            if (!variantName) return 'Unknown';
            const name = variantName.toLowerCase();
            const isMLG = playlist === 'MLG 4v4' || playlist === 'Team Hardcore' ||
                          playlist.toLowerCase().includes('tournament');

            if (name.includes('flag') || name.includes('ctf')) return 'Capture the Flag';
            if (name.includes('oddball') || name.includes('ball') || name.includes('bawl')) return 'Oddball';
            if (name.includes('king') || name.includes('koth') || name.includes('hill')) return 'King of the Hill';
            if (name.includes('assault') || name.includes('bomb')) return isMLG ? 'Bomb' : 'Assault';
            if (name.includes('territor')) return 'Territories';
            if (name.includes('ffa') || name.includes('free for all') || name.includes('rumble')) return 'Free For All';
            if (name.includes('slayer') || name.includes(' ts') || name === 'ts' || name.endsWith('ts')) return 'Team Slayer';
            return variantName;
        }

        function getGametypeWithPrefix(gameType, playlist) {
            if (!playlist) return gameType;
            const playlistLower = playlist.toLowerCase();
            if (playlistLower === 'mlg 4v4' || playlistLower === 'team hardcore' || playlistLower.includes('tournament')) {
                return 'MLG ' + gameType;
            } else if (playlistLower === 'double team') {
                return '2v2 ' + gameType;
            } else if (playlistLower === 'head to head') {
                return '1v1 ' + gameType;
            }
            return gameType;
        }

        function getDisplayGametype(variantName, playlist) {
            const baseType = getBaseGametype(variantName, playlist);
            return getGametypeWithPrefix(baseType, playlist);
        }

        function renderGamesList() {
            const gamesList = document.getElementById('playlistGamesList');
            if (!gamesList || matchesData.length === 0) {
                if (gamesList) gamesList.innerHTML = '<div class="loading">No games to display</div>';
                return;
            }

            gamesList.innerHTML = '';
            const sortedMatches = [...matchesData].sort((a, b) => {
                const dateA = new Date(a.timestamp || 0);
                const dateB = new Date(b.timestamp || 0);
                return dateB - dateA;
            });

            sortedMatches.forEach((match, index) => {
                const gameItem = createGameItem(match, index);
                gamesList.appendChild(gameItem);
            });
        }

        function createGameItem(match, gameIndex) {
            const gameDiv = document.createElement('div');
            gameDiv.className = 'game-item';
            gameDiv.id = `playlist-game-${gameIndex}`;

            const mapName = match.map || 'Unknown Map';
            const rawGametype = match.gametype || 'Unknown';
            const gametype = getDisplayGametype(rawGametype, playlistConfig?.name || '');
            const dateDisplay = formatDateTime(match.timestamp);

            let winnerClass = '';
            let teamScoreDisplay = '';

            if (match.red_score !== undefined && match.blue_score !== undefined) {
                if (match.winner === 'Red') {
                    winnerClass = 'winner-red';
                } else if (match.winner === 'Blue') {
                    winnerClass = 'winner-blue';
                }
                teamScoreDisplay = `<span class="game-meta-tag">Red: ${match.red_score} - Blue: ${match.blue_score}</span>`;
            }

            // Get bracket info for this match (tournament games only)
            let bracketBadge = '';
            if (bracketConfig) {
                const bracketInfo = getBracketInfoForMatch(match);
                if (bracketInfo) {
                    bracketBadge = `<span class="bracket-info-badge">${bracketInfo.round} Game ${bracketInfo.gameNumber}</span>`;
                }
            }

            gameDiv.innerHTML = `
                <div class="game-header-bar ${winnerClass}" onclick="toggleGameDetails(${gameIndex})">
                    <div class="game-header-left">
                        <div class="game-info">
                            <span class="game-type-title">${gametype}</span>
                            <span class="game-meta-tag">${mapName}</span>
                            ${teamScoreDisplay}
                        </div>
                    </div>
                    ${bracketBadge}
                    <div class="game-header-right">
                        ${dateDisplay ? `<span class="game-meta-tag date-tag">${dateDisplay}</span>` : ''}
                        <div class="expand-icon">▶</div>
                    </div>
                </div>
                <div class="game-details">
                    <div class="game-details-content">
                        <div id="playlist-game-content-${gameIndex}"></div>
                    </div>
                </div>
            `;

            return gameDiv;
        }

        function toggleGameDetails(gameIndex) {
            const gameItem = document.getElementById(`playlist-game-${gameIndex}`);
            const gameContent = document.getElementById(`playlist-game-content-${gameIndex}`);

            if (!gameItem) return;

            const isExpanded = gameItem.classList.contains('expanded');

            if (isExpanded) {
                gameItem.classList.remove('expanded');
            } else {
                gameItem.classList.add('expanded');
                if (!gameContent.innerHTML) {
                    const sortedMatches = [...matchesData].sort((a, b) => {
                        const dateA = new Date(a.timestamp || 0);
                        const dateB = new Date(b.timestamp || 0);
                        return dateB - dateA;
                    });
                    const match = sortedMatches[gameIndex];
                    if (match) {
                        gameContent.innerHTML = renderGameContent(match, gameIndex);
                    }
                }
            }
        }

        function renderGameContent(match, gameIndex) {
            const mapName = match.map || 'Unknown';
            const mapImage = mapImages[mapName] || defaultMapImage;
            const rawGametype = match.gametype || 'Unknown';
            const gametype = getDisplayGametype(rawGametype, playlistConfig?.name || '');
            const duration = formatDuration(match.duration);
            const formattedTime = formatDateTime(match.timestamp);

            let teamScoreHtml = '';
            if (match.red_score !== undefined && match.blue_score !== undefined) {
                const redWinner = match.winner === 'Red';
                const blueWinner = match.winner === 'Blue';
                teamScoreHtml = '<div class="game-final-score">';
                teamScoreHtml += `<span class="final-score-team team-red${redWinner ? ' winner' : ''}">Red: ${match.red_score}</span>`;
                teamScoreHtml += '<span class="score-separator">vs</span>';
                teamScoreHtml += `<span class="final-score-team team-blue${blueWinner ? ' winner' : ''}">Blue: ${match.blue_score}</span>`;
                teamScoreHtml += '</div>';
            }

            let html = '<div class="game-details-header">';
            html += `<div class="map-image-container">`;
            html += `<img src="${mapImage}" alt="${mapName}" class="map-image" onerror="this.src='${defaultMapImage}'">`;
            html += `<div class="map-overlay"><div class="map-name">${mapName}</div></div>`;
            html += `</div>`;
            html += `<div class="game-info-panel">`;
            html += `<div class="game-type-title">${gametype}</div>`;
            html += `<div class="game-meta-info">`;
            html += `<span><i class="icon-clock"></i> ${duration}</span>`;
            html += `<span><i class="icon-calendar"></i> ${formattedTime}</span>`;
            const playlistName = playlistConfig?.name || '';
            if (playlistName) {
                html += `<a href="/playlist.html?name=${encodeURIComponent(playlistName)}" class="playlist-link" onclick="event.stopPropagation();">${playlistName}</a>`;
            }
            html += `</div>`;
            html += teamScoreHtml;
            html += `</div></div>`;

            // Scoreboard
            html += '<div class="scoreboard"><table class="scoreboard-table">';
            html += '<thead><tr><th>Player</th><th>K</th><th>D</th><th>A</th><th>Score</th></tr></thead><tbody>';

            const players = match.player_stats || [];
            const sortedPlayers = [...players].sort((a, b) => {
                const teamOrder = { 'Red': 0, 'Blue': 1 };
                return (teamOrder[a.team] || 2) - (teamOrder[b.team] || 2);
            });

            sortedPlayers.forEach(player => {
                const teamClass = player.team ? `team-${player.team.toLowerCase()}` : '';
                const emblemUrl = getPlayerEmblem(player.name);
                html += `<tr class="${teamClass}">`;
                html += `<td class="player-cell">`;
                if (emblemUrl) html += `<img src="${emblemUrl}" class="player-emblem" alt="">`;
                html += `<span class="player-name" onclick="goToPlayer('${player.name}')">${player.name}</span></td>`;
                html += `<td>${player.kills || 0}</td>`;
                html += `<td>${player.deaths || 0}</td>`;
                html += `<td>${player.assists || 0}</td>`;
                html += `<td>${player.score || 0}</td></tr>`;
            });

            html += '</tbody></table></div>';
            return html;
        }

        function goToPlayer(playerName) {
            window.location.href = `/#${encodeURIComponent(playerName)}`;
        }

        function calculateStatsFromMatches(matchesArray) {
            const playerStats = {};
            for (const match of matchesArray) {
                const winner = match.winner;
                for (const playerStat of match.player_stats || []) {
                    const name = playerStat.name;
                    if (!playerStats[name]) {
                        playerStats[name] = {
                            discord_name: name,
                            wins: 0, losses: 0, kills: 0, deaths: 0, assists: 0, headshots: 0
                        };
                    }
                    const p = playerStats[name];
                    p.kills += playerStat.kills || 0;
                    p.deaths += playerStat.deaths || 0;
                    p.assists += playerStat.assists || 0;
                    p.headshots += playerStat.headshots || 0;
                    if (playerStat.team === winner) p.wins++;
                    else p.losses++;
                }
            }
            return { players: playerStats };
        }

        async function loadPlaylistStats() {
            const playlistName = getPlaylistName();
            if (!playlistName) {
                showError('No playlist specified in URL.');
                return;
            }

            document.title = `${playlistName} - CarnageReport.com`;

            try {
                const playlistsResponse = await fetch('playlists.json');
                if (!playlistsResponse.ok) throw new Error('Could not load playlists config');
                const playlistsConfig = await playlistsResponse.json();

                playlistConfig = playlistsConfig.playlists.find(p =>
                    p.name.toLowerCase() === playlistName.toLowerCase()
                );

                if (!playlistConfig) throw new Error(`Playlist "${playlistName}" not found`);

                // Load bracket config if available
                bracketConfig = playlistConfig.bracket || null;

                // Load MMR and emblems data
                try {
                    const [mmrRes, emblemsRes] = await Promise.all([
                        fetch('MMR.json'),
                        fetch('emblems.json')
                    ]);
                    if (mmrRes.ok) mmrData = await mmrRes.json();
                    if (emblemsRes.ok) emblemsData = await emblemsRes.json();
                } catch (e) {
                    console.warn('Could not load MMR/emblems:', e);
                }

                // Load matches
                const matchesResponse = await fetch(playlistConfig.matches_file);
                if (!matchesResponse.ok) throw new Error(`Matches data not found`);
                const matchesJson = await matchesResponse.json();
                matchesData = matchesJson.matches || [];

                // Calculate stats
                const statsData = calculateStatsFromMatches(matchesData);
                playersData = Object.entries(statsData.players || {}).map(([id, data]) => ({
                    discord_id: id, ...data
                }));

                // Show content
                document.getElementById('loadingArea').style.display = 'none';
                document.getElementById('contentArea').style.display = 'block';
                document.getElementById('playlistName').textContent = playlistName;

                if (playlistConfig.date) {
                    document.getElementById('playlistDate').textContent = playlistConfig.date;
                }

                // Hide bracket tab for non-tournament playlists
                if (!bracketConfig) {
                    document.querySelector('[data-tab="bracket"]').style.display = 'none';
                    document.querySelector('[data-tab="games"]').classList.add('active');
                    document.getElementById('tab-games').classList.add('active');
                    document.getElementById('tab-bracket').classList.remove('active');
                }

                renderSummary();
                if (bracketConfig) {
                    renderBracket();
                    buildBracketGameMapping();
                }
                renderPlayersTable();
                renderGamesList();

            } catch (error) {
                showError(error.message);
            }
        }

        function showError(message) {
            document.getElementById('loadingArea').style.display = 'none';
            document.getElementById('errorArea').style.display = 'block';
            document.getElementById('errorText').textContent = message;
        }

        document.addEventListener('DOMContentLoaded', loadPlaylistStats);
    </script>
</body>
</html>
